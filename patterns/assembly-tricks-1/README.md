# æ±‡ç¼–æŠ€å·§ - 1
- [ğŸ æµ‹è¯•](../../test/AssemblyTricks1.t.sol)

ä»¥ä¸‹æ˜¯ä¸€äº›ç®€çŸ­ä½†å®ç”¨çš„çš„æ±‡ç¼–æŠ€å·§é›†åˆï¼Œå®ƒä»¬å¯ä»¥å¸®åŠ©ä½ èŠ‚çœå¤§é‡çš„ gasï¼Œå¹¶å¸®åŠ©ç»•å¼€ä¸€äº› Solidity æœ¬èº«çš„é™åˆ¶ã€‚
ä½†æ˜¯ä¸€å®šè¦éå¸¸æ³¨æ„ä½¿ç”¨è¿™äº›æŠ€æœ¯çš„æ–¹å¼å’Œæ—¶æœºï¼Œå› ä¸ºä¸æ°å½“çš„ä½¿ç”¨æˆ–è€…æ˜¯ä¸æ­£ç¡®çš„å®ç°æ–¹å¼å¯èƒ½ä¼šå¯¼è‡´éå¸¸ä¸¥é‡ä¸”éš¾ä»¥å‘ç°çš„é”™è¯¯ã€‚


## é”™è¯¯å†’æ³¡ (è®©é”™è¯¯ç»§ç»­æ²¿ç€è°ƒç”¨æ ˆå‘ä¸Šä¼ é€’)

ä»¥ä¸‹è¿™äº›æ–¹å¼æ˜¯éå¸¸å¸¸è§çš„å‘å¦ä¸€ä¸ªåˆçº¦ï¼ˆæˆ– EOAï¼‰å‘èµ·è°ƒç”¨çš„æ–¹å¼ï¼Œä»–ä»¬çš„å…±åŒç‚¹æ˜¯è¢«è°ƒç”¨å‡½æ•°çš„é”™è¯¯å›æ»šä¸ä¼šè¿›ä¸€æ­¥è°ƒç”¨æ–¹æœ¬èº«æŠ¥é”™å¹¶å›æ»šï¼š

1. ä½¿ç”¨åº•å±‚è°ƒç”¨ä¾‹å¦‚ `call()`, `delegatecall()`, `staticcall()`ã€‚
2. ä½¿ç”¨ `try`/`catch` è¯­å¥ã€‚

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä½ çš„ä»£ç åœ¨è¢«è°ƒç”¨å‡½æ•°æŠ¥é”™åç»§ç»­æ‰§è¡Œï¼Œè¿”å›å€¼æ˜¯è°ƒç”¨è€…ä»¥ `bytes` æ•°ç»„å½¢å¼è¿”å›çš„é”™è¯¯æ•°æ®ã€‚
ä½ å¯èƒ½æƒ³è¦ä½¿ç”¨ä½¿ç”¨[é”™è¯¯å¤„ç†](../error-handling)è¿™ä¸€èŠ‚ä¸­å­¦åˆ°çš„æŠ€å·§æ¥å¤„ç†æŸäº›é”™è¯¯ï¼Œä½†å¦‚æœç¢°åˆ°å…¶ä»–é”™è¯¯ï¼Œåˆ™é‡æ–°æŠ›å‡ºã€‚
è¿™é‡Œæ¯”è¾ƒå¸¸è§çš„åšæ³•æ˜¯ç®€å•åœ°å°† `bytes` é”™è¯¯æ•°æ®è½¬æ¢ä¸º `string`ï¼Œå¹¶å°†å…¶ä¼ å…¥ `revert()`ï¼Œä½†è¿™å®é™…ä¸Šæ˜¯é”™è¯¯çš„ï¼Œ
å› ä¸º `revert` ä¼šå°†ä¼ å…¥çš„å­—ç¬¦ä¸²é‡æ–°ç¼–ç ä¸ºåŸç”Ÿé”™è¯¯ `Error(string)` çš„å½¢å¼ï¼Œä»è€Œå¯¼è‡´äº†åŒé‡ç¼–ç ï¼š

```solidity
// This is the WRONG way to re-throw raw revert data (`revertBytes`) because it
// re-encodes the revert data as an `Error(string)` revert type. 
revert(string(revertBytes))
```

ç›¸åï¼Œè¿™é‡Œå¯ä»¥è€ƒè™‘ç›´æ¥ä½¿ç”¨æ±‡ç¼–æ¥æŠ›å‡ºå®é™…çš„é”™è¯¯æ•°æ®ï¼ˆè¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä»…åœ¨ `revertBytes` å­˜åœ¨å†…å­˜ä¸­æ—¶å¯è¡Œï¼Œ
å½“ç„¶ç»å¤§éƒ¨åˆ†æƒ…å†µå®ƒéƒ½æ˜¯å­˜åœ¨å†…å­˜ä¸­çš„ï¼‰ï¼š

```solidity
// Re-throw `revertBytes` revert data as-is.
assembly { revert(add(revertBytes, 0x20), mload(revertBytes)) }
```

ç±»ä¼¼çš„ï¼Œåœ¨ `try/catch` ä¸­ä½¿ç”¨ä¹Ÿå¾ˆç®€å•ï¼

```solidity
try otherContract.foo() {
    // handle successful call...
} catch (bytes memory revertBytes) {
    // call failed, do some error processing
    // if all else fails, bubble up the revert
    assembly { revert(add(revertBytes, 0x20), mload(revertBytes)) }
}
```

## è®¡ç®—ä¸¤ä¸ªå•ç‹¬çš„ 32 å­—èŠ‚ç±»å‹çš„å“ˆå¸Œå€¼

ç°å®ä¸­ç»å¸¸ä¼šé‡åˆ°éœ€è¦å¯¹ä¸¤ä¸ª 32 å­—èŠ‚å€¼è¿›è¡Œå“ˆå¸Œçš„æƒ…å†µï¼Œæ¯”å¦‚åœ¨ [traversing merkle trees](../merkle-proofs/) ä¸­ã€‚
ç”±äº `keccak256()`ï¼ˆå†…ç½®å“ˆå¸Œå‡½æ•°ï¼‰æ¥æ”¶å­—èŠ‚æ•°ç»„ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šæƒ³åˆ°å…ˆä½¿ç”¨ `abi.encode()` å°†ä¸¤ä¸ªå•è¯è¿›è¡Œæ‹¼æ¥åå†åšå“ˆå¸Œï¼š

```solidity
uint256 word1 = ...;
bytes32 word2 = ...;
// Concatenate `word1` and `word2` then compute their hash.
bytes32 hash = keccak256(abi.encode(word1, word2));
```

ä¸Šè¿°æ“ä½œå¯¹äºä»»æ„æ•°æ®ç±»å‹å’Œæ•°é‡éƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œä½†å¦‚æœä½ åªéœ€è¦å“ˆå¸Œä¸¤ä¸ª 32 å­—èŠ‚çš„å€¼ï¼ˆæˆ–è€…ç»„åˆèµ·æ¥æ˜¯ 64 å­—èŠ‚çš„å€¼ï¼‰ï¼Œä½ å¯ä»¥ä½¿ç”¨ä¸€äº›ç®€å•çš„æ±‡ç¼–ä»¥æ›´å°çš„ gas æˆæœ¬æ¥åšåˆ°åŒæ ·çš„äº‹æƒ…ï¼š


```solidity
bytes32 hash;
assembly {
    mstore(0x00, word1)
    mstore(0x20, word2)
    hash := keccak256(0x00, 0x40)
}
```

è¿™æ¯”å¸¸è§„çš„ `keccak256(abi.encode())` æˆæœ¬æ›´å°æ˜¯å› ä¸º `abi.encode()` ä¼šåˆ†é…ä¸€ä¸ªæ–°çš„å†…å­˜ç¼“å†²åŒºï¼Œ
ç„¶åç”¨è¿™ä¸ªç¼“å†²åŒºæ¥æŠŠä¸¤ä¸ªå€¼æ‹¼æ¥åˆ°ä¸€èµ·ï¼Œæœ€åå†ä¼ ç»™ `keccak256()`ã€‚è€Œæ±‡ç¼–ç‰ˆæœ¬åªæ˜¯æŠŠè¿™ä¸¤ä¸ªå€¼æ‹¼æ¥åœ¨å†…å­˜çš„å¤´ä¸¤ä¸ªæ§½ä½ä¸­ï¼ˆ0x00-0x40ï¼‰ï¼Œè¿™åœ¨ EVM çš„è§„èŒƒä¸­æ˜¯å…è´¹å¯ç”¨çš„ä¸´æ—¶ç©ºé—´ï¼Œä»è€Œé¿å…äº†åˆ†é…æ–°çš„å†…å­˜å¯¼è‡´çš„å†…å­˜æ‰©å±•å¸¦æ¥çš„ gas å¼€é”€ã€‚


## åœ¨ä¸¤ç§æ•°ç»„ç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢

Solidity ä¸å…è®¸ä½ ç›´æ¥è½¬æ¢ä¸åŒå…ƒç´ ç±»å‹çš„æ•°ç»„ï¼ˆ`bytes` å’Œ `string` ç±»å‹æ˜¯ä¸€ä¸ªä¾‹å¤–ï¼‰ã€‚å¦‚æœä½ åœ¨ä½ çš„é¡¹ç›®ä¸­å¯¼å…¥ç¬¬ä¸‰æ–¹åº“ï¼Œä½ æœ‰æ—¶ä¼šé‡åˆ°è¿™æ ·çš„æƒ…å†µï¼Œä¸€ä¸ªå¯¼å…¥çš„å‡½æ•°æ¥æ”¶çš„æ•°ç»„ç±»å‹å’Œä½ åœ¨ä½ çš„ä»£ç ä¸­ä½¿ç”¨çš„æ•°ç»„ç±»å‹ä¸åŒï¼Œä½†ä½ çŸ¥é“å®ƒä»¬åœ¨åº•å±‚å…¶å®æ˜¯å…¼å®¹çš„ã€‚è¿™äº›ä¾‹å­åŒ…æ‹¬ï¼š

- `address[]` vs `address payable[]`
- `address[]` vs `interface[]`
- `address[]` vs `contract[]`
- `uint160[]` vs `address[]`
- `uint256[]` vs `bytes32[]`
- `uint256[N]` vs `bytes32[N]` 
- etc.

æœ€ç›´è§‚çš„ï¼Œä½ å¯ä»¥é€šè¿‡éå†æ•´ä¸ªæ•°ç»„æ¥å¯¹æ¯ä¸ªå…ƒç´ è¿›è¡Œè½¬æ¢ï¼Œä½†æ˜¯å› ä¸ºè½¬æ¢è¿‡ç¨‹è¿˜é¢å¤–å¤åˆ¶äº†æ¯ä¸ªå…ƒç´ ï¼Œæ‰€ä»¥ gas å¼€é”€å¾ˆå¤§ï¼š

```solidity
// Doing a conversion between compatible array types the hard way.
address[] memory addressArr = ...;
IERC20[] memory erc20Arr = new IERC20[](addressArr.length);
for (uint256 i; i < addressArr.length; ++i) {
    erc20Arr[i] = addressArr[i];
}
```

å®é™…ä¸Šï¼Œå˜é‡æœ¬èº«åªæ˜¯å­˜å‚¨åœ¨å †æ ˆä¸Šçš„æŒ‡é’ˆ, å®ƒæ‰€æŒ‡å‘çš„å†…å­˜æ‰æ˜¯ `memory` æ•°ç»„æ•°æ®ï¼Œä½¿ç”¨æ±‡ç¼–å¯ä»¥è®©ä½ ç›´æ¥æ›´æ–°æŸä¸ªå˜é‡ä¸­å­˜å‚¨çš„æŒ‡é’ˆã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­åªéœ€è¦æ–°å»ºä¸€ä¸ªç›®æ ‡ç±»å‹çš„æ•°ç»„å˜é‡ç„¶åå°†å…¶æŒ‡é’ˆæŒ‡å‘åŸæ•°ç»„åœ¨ `memory` ä¸­çš„ä½ç½®å³å¯ã€‚å› æ­¤ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹å¼å¾ˆå®¹æ˜“åœ°æ»¡è¶³å‰é¢ä¾‹å­çš„è¦æ±‚ï¼š


```solidity
// Cheaply cast between compatible dynamic arrays. 
address[] memory addressArr = ...;
IERC20Token[] memory erc20Arr; // No need to allocate new memory.
// Point `erc20Arr` to the same location as `addressArr`
assembly { erc20Arr := addressArr }
```

è¯¥æ–¹å¼åœ¨é™æ€å†…å­˜æ•°ç»„ä¹‹é—´ä¹Ÿå¯ä»¥å·¥ä½œï¼Œä½†ç›¸è¾ƒåŠ¨æ€æ•°ç»„ï¼Œè¿™ç§åœºæ™¯ä¸‹å¸¦æ¥çš„ gas æ”¶ç›Šä¼šå°ä¸€äº›ï¼Œå› ä¸ºå£°æ˜é™æ€æ•°ç»„æ—¶ EVM ä¼šç«‹å³ä¸ºå®ƒåˆ†é…æ–°çš„å†…å­˜ï¼š

```solidity
// Cheaply cast between compatible statically sized arrays. 
address[3] memory addressArr = ...;
IERC20Token[3] memory erc20Arr;
// Point `erc20Arr` to the same location as `addressArr`
assembly { erc20Arr := addressArr }
```

æ³¨æ„ï¼Œè¿™äº›æ–¹æ³•ä¸é€‚ç”¨äº `calldata` æ•°ç»„ï¼Œå› ä¸ºä»–ä»¬çš„æŒ‡é’ˆå¯¹åº”çš„åº•å±‚å®ç°æ˜¯å®Œå…¨ä¸åŒçš„ã€‚

## ä¸åŒç±»å‹çš„ç»“æ„ä½“ä¹‹é—´çš„è½¬æ¢

ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å‰é¢çš„æ•°ç»„è½¬æ¢æŠ€å·§åœ¨*å…¼å®¹*  `memory` ç»“æ„ä½“ä¹‹é—´è½¬æ¢ï¼š

```solidity
struct Foo {
    address addr;
    uint256 x;
}

// All fields in `Bar` are bit-compatible with `Foo`. 
struct Bar {
    IERC20 erc20;
    bytes32 x;
}

Foo memory foo = MyStruct({...});
// Point `bar` to the contents of `foo`.
Bar memory bar;
assembly { bar := foo }
```

ç»“æ„ä½“å’Œé™æ€æ•°ç»„åœ¨å†…å­˜åˆ†é…æ–¹å¼ä¸Šå®é™…ä¸Šæ˜¯ç±»ä¼¼çš„ï¼Œæ‰€ä»¥è¿™ç§æ–¹æ³•ä¼šäº§ç”Ÿä¸é™æ€æ•°ç»„ä¸€æ ·çš„å†…å­˜æ‰©å±•å¸¦æ¥çš„é¢å¤– gas å¼€é”€ï¼Œä½†ç›¸æ¯”ä¸€ä¸ªå­—æ®µä¸€ä¸ªå­—æ®µåœ°æ‰‹åŠ¨è½¬æ¢ï¼Œè¿˜æ˜¯èŠ‚çœäº†ä¸å°‘å¤åˆ¶æ“ä½œå¸¦æ¥çš„å¼€é”€ã€‚


## ç¼©çŸ­åŠ¨æ€å†…å­˜æ•°ç»„çš„é•¿åº¦
åŠ¨æ€å¤§å°çš„å†…å­˜æ•°ç»„å˜é‡æŒ‡å‘çš„å†…å­˜ä½ç½®çš„å‰ 32 å­—èŠ‚åŒ…å«äº†æ•°ç»„çš„é•¿åº¦ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ ç´§éšå…¶åã€‚

```
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
arr = new uint256[N]() â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚      Length = N        â”‚  ptr + 0x00
                               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                               â”‚      Element 0         â”‚  ptr + 0x20
                               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                               â”‚      Element 1         â”‚  ptr + 0x40
                               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                               â”‚         ...            â”‚
                               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                               â”‚      Element N         â”‚  ptr + 0x20 * N
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


ä½¿ç”¨æ±‡ç¼–ï¼Œä½ å¯ä»¥ç›´æ¥å†™å…¥è¿™ä¸ªä½ç½®æ¥æ”¹å˜å­˜å‚¨çš„æ•°ç»„é•¿åº¦ï¼ âš ï¸ è¯·è®°ä½ï¼Œé€šå¸¸åªæœ‰ç¼©å°æ•°ç»„å¤§å°æ‰æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæ‰©å¤§æ•°ç»„å¯èƒ½ä¼šå¯¼è‡´ä½ è¯»å†™å·²ç»ä¸ºå…¶ä»–å˜é‡é¢„ç•™çš„å†…å­˜ä½ç½® âš ï¸ã€‚


```solidity
uint256[] memory arr = new uint256[](100);
assert(arr.length == 100);
// Shorten the `arr` dynamic array by 1 (ignoring the last element).
assembly { mstore(arr, 99) }
assert(arr.length == 99);
```

è¿™ç§æ–¹å¼ä¿®æ”¹äº†åŸæ•°ç»„çš„é•¿åº¦ï¼Œæ‰€ä»¥éœ€è¦ç¡®ä¿ç›¸å…³çš„ä»£ç é€»è¾‘æ˜¯å¦éœ€è¦ä¾èµ–æ•°ç»„é•¿åº¦ä¿æŒä¸å˜ã€‚


## ç¼©çŸ­é™æ€é•¿åº¦çš„å†…å­˜æ•°ç»„

é™æ€å¤§å°çš„æ•°ç»„*ä¸ä¼š*åœ¨æŒ‡é’ˆæŒ‡å‘çš„ä½ç½®å¼€å¤´æ•°ç»„å­˜å‚¨é•¿åº¦ï¼Œå› ä¸ºé•¿åº¦åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šäº†ï¼Œæ‰€ä»¥ä¸Šè¿°æ–¹æ³•å¯¹å®ƒä»¬ä¸èµ·ä½œç”¨ã€‚ä½†æ˜¯ä½ å¯ä»¥ä½¿ç”¨æ•°ç»„è½¬æ¢æŠ€å·§æ¥åˆ›å»ºä¸€ä¸ªå›ºå®šé•¿åº¦çš„å¼•ç”¨ï¼Œè¿™ä¸ªå¼•ç”¨æ˜¯åŸå§‹æ•°ç»„çš„ä¸€ä¸ªå­é›†ã€‚è™½ç„¶åŒæ ·éœ€è¦å£°æ˜ä¸€ä¸ªæ–°çš„é™æ€æ•°ç»„å˜é‡ï¼Œå› æ­¤æ— å¯é¿å…çš„ä¼šæ‰©å±•å†…å­˜ï¼Œä½†ä»ç„¶å¯ä»¥èŠ‚çœå¤åˆ¶æ¯ä¸ªå…ƒç´ å¸¦æ¥çš„ gas å¼€é”€ï¼š

```solidity
uint256[10] memory arr;
// Shorten the `arr` fixed array by 1 (ignoring the last element).
uint256[9] memory shortArr;
assembly { shortArr := arr }
```


å› ä¸ºé™æ€å¤§å°çš„æ•°ç»„æ²¡æœ‰é•¿åº¦å‰ç¼€ï¼Œæ‰€ä»¥ä½ ç”šè‡³å¯ä»¥å°†æ–°å˜é‡æŒ‡å‘åŸå§‹æ•°ç»„å†…çš„ä¸€ä¸ªåç§»ä½ç½®ï¼Œä»¥æ­¤æ¥åˆ›å»ºä¸€ä¸ªå…±äº«åˆ‡ç‰‡ï¼

```solidity
uint256[10] memory arr;
// Create a shared slice of the original array, starting at the 2nd (idx 1) element to the 9th (idx 8).
uint256[8] memory shortArr;
assembly { shortArr := add(arr, 0x20) }
```

