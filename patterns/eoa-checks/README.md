# ä¸ªäººé’±åŒ…åœ°å€ï¼ˆéåˆçº¦åœ°å€ï¼‰æ£€æŸ¥
- [ğŸ“œ ç¤ºä¾‹ä»£ç ](./KingOfTheHill.sol)
- [ğŸ æµ‹è¯•](../../test/KingOfTheHill.t.sol)

ä¸ªäººé’±åŒ…åœ°å€æŒ‡çš„æ˜¯é‚£äº›ä»æŸç§é’¥ç»è¿‡åŠ å¯†ç®—æ³•äº§ç”Ÿè€Œæ¥çš„åœ°å€ã€‚è¿™äº›åœ°å€ä¸æ˜¯æ™ºèƒ½åˆçº¦ï¼Œä¹Ÿæ°¸è¿œä¸ä¼šæˆä¸ºæ™ºèƒ½åˆçº¦åœ°å€ã€‚è¯´ç®€å•ç‚¹ï¼Œè¿™äº›å°±æ˜¯æœ€æ™®éæ„ä¹‰ä¸Šçš„é’±åŒ…åœ°å€ï¼Œæ¯”å¦‚å°ç‹ç‹¸é’±åŒ…åœ°å€ï¼Œå†·é’±åŒ…åœ°å€ï¼Œè¿˜æœ‰çº¸é’±åŒ…åœ°å€ç­‰ç­‰ã€‚å¦ä¸€ç§ä¸åŒæ¦‚å¿µçš„é’±åŒ…æ¯”å¦‚Argentå’ŒGnosis Safeæ˜¯â€œæ™ºèƒ½â€é’±åŒ…ï¼Œä»–ä»¬å®é™…ä¸Šæ˜¯å®šä¹‰äº†åƒé’±åŒ…ä¸€æ ·çš„åŠŸèƒ½çš„æ™ºèƒ½åˆçº¦ä»£ç ã€‚

å¼€å‘äººå‘˜ç»å¸¸éœ€è¦è€ƒè™‘åˆ°æ­£åœ¨ä¸ä¹‹äº¤äº’çš„åœ°å€æ˜¯ä¸ªäººåœ°å€è¿˜æ˜¯åˆçº¦åœ°å€ã€‚äº†è§£å®ƒä»¬ä¹‹é—´çš„åŒºåˆ«ä¸åæœæ˜¯å¾ˆé‡è¦çš„ï¼Œå°¤å…¶æ˜¯ä½ æƒ³è¦å†™ä¸€ä¸ªæ¯”è¾ƒå®Œå–„çš„å¯¹æ¶æ„è¡Œä¸ºæœ‰é˜²å¾¡æ€§çš„åˆçº¦ã€‚è®©æˆ‘ä»¬æ¥å¿«é€Ÿè¿‡ä¸€éè¿™äº›åŒºåˆ«å’Œå®ƒä»¬ä¼šå¯¹ä½ çš„åˆçº¦äº§ç”Ÿä»€ä¹ˆæ ·çš„å½±å“ã€‚

### å‘XXXå‘èµ·è°ƒç”¨
ä»»ä½•è¯•å›¾å¯¹ä¸€ä¸ªä¸ªäººåœ°å€å‘èµ·çš„å‡½æ•°è°ƒç”¨éƒ½ä¼šæˆåŠŸï¼Œä½†æ˜¯æ²¡æœ‰ä»£ç ä¼šè¢«æ‰§è¡Œä¹Ÿæ²¡æœ‰æ•°æ®è¢«è¿”å›ã€‚å¦‚æœè¿™ä¸ªå°è¯•çš„å‡½æ•°é€»è¾‘æœ¬èº«å°±ä¸å¸¦è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿™ç§æƒ…å†µå°±å®¹æ˜“è·Ÿâ€œè¯•å›¾å¯¹çœŸçš„åˆçº¦è¿›è¡Œå‡½æ•°è°ƒç”¨å¹¶ä¸”çœŸçš„æ‰§è¡Œäº†â€æœ‰æ‰€æ··æ·†ï¼Œå› ä¸ºä¸¤ç§è¡Œä¸ºéƒ½ä¸å¸¦è¿”å›å€¼ã€‚æ‰€ä»¥è¦æ˜ç¡®è¢«å‘å»è°ƒç”¨çš„åœ°å€åˆ°åº•æ˜¯ä¸æ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦ï¼Œè¿™æ˜¯å¾ˆé‡è¦çš„ã€‚

### è¢«æ¥è‡ªäºXXXè°ƒç”¨
çœŸæ­£çš„ä¸ªäººåœ°å€ï¼ˆç”±ç§é’¥è¡ç”Ÿè€Œæ¥çš„ï¼‰[ç›®å‰](https://eips.ethereum.org/EIPS/eip-3074)åªèƒ½åœ¨*æ¯é¡¹äº¤æ˜“*é‡Œå‘èµ·ä¸€æ¡ç›´æ¥çš„å‡½æ•°è°ƒç”¨ï¼Œç„¶è€Œæ™ºèƒ½åˆçº¦å‘èµ·å‡½æ•°è°ƒç”¨æ—¶å´ä¸å—æ­¤é™ã€‚é‡å…¥æ”»å‡»ï¼Œå¥—åˆ©äº¤æ˜“ï¼Œé¢„è¨€æœºæ“çºµï¼Œé—ªç”µè´·æ”»å‡»ç­‰ç­‰è¿™äº›è¡Œä¸ºè‹¥æ˜¯ä»ä¸€ä¸ªæ™ºèƒ½åˆçº¦çš„ä¸€é¡¹äº¤æ˜“ä¸­å‘èµ·ï¼Œå°±æ¯”ä»ä¸ªäººåœ°å€è€Œæ¥çš„è‹¥å¹²é¡¹ç»„åˆäº¤æ˜“çš„å®Œæˆæ–¹å¼è¦æ›´åŠ ç®€å•å¯è¡Œæœ‰åˆ©å¯å›¾ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä½•é‚£äº›å‘ç”Ÿè¿‡çš„é‡å¤§æ”»å‡»äº‹ä»¶éƒ½æ˜¯å…ˆè¡Œéƒ¨ç½²ä¸€ä¸ªç”¨æ¥æ”»å‡»çš„æ™ºèƒ½åˆçº¦ï¼Œç„¶åè¿™äº›æ”»å‡»è¡Œä¸ºéƒ½åœ¨åŒä¸€æ¡äº¤æ˜“ä¸­ä¸€æ¬¡æ€§å‘èµ·ã€‚

### ETHè½¬è´¦
åœ¨EVMå±‚é¢ï¼Œçº¯ç²¹çš„ETHè½¬è´¦ï¼ˆä¾‹å¦‚  `address(receiver).transfer(1 ether)`, `address(receiver).send(1 ether)`, or `address(receiver).call{value: 1 ether}("")`ï¼‰éƒ½ä¼šè®¤åšä¸€ä¸ªä¸å«æœ‰calldataçš„ç©ºå‡½æ•°è°ƒç”¨ã€‚æ­£å¦‚å‰é¢æåˆ°è¿‡çš„ï¼Œä»»ä½•å‘EOAå‘èµ·çš„è°ƒç”¨éƒ½ä¼šæˆåŠŸå¹¶ä¸”ä¸æ‰§è¡Œä»€ä¹ˆä»£ç ã€‚ä½†æ˜¯å¦‚æœè½¬è´¦ç›®æ ‡å®é™…æ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦ï¼Œå®ƒå°±ä¼šå»è¿è¡Œè¿™ä¸ªåˆçº¦çš„å­—èŠ‚ç ï¼Œåˆçº¦æ–¹è·å¾—äº†æ‰§è¡Œä»£ç çš„æƒåˆ©æ¥åšå®ƒä»¬è®¾è®¡å¥½è¦åšçš„äº‹æƒ…ï¼ˆåœ¨gaså¤Ÿç”¨çš„å‰æä¸‹ï¼‰ã€‚é™¤äº†å¹¿ä¸ºäººçŸ¥çš„ç”¨è¿™ä¸ªæœºä¼šæ¥åšé‡å…¥æ”»å‡»ï¼Œæ¶æ„çš„åˆçº¦è¿˜å¯ä»¥å•çº¯åœ°è®©äº¤æ˜“é€†è½¬ï¼Œè¿™æ ·ä½ çš„åˆçº¦çš„è¿™ä¸ªå‡½æ•°æ‰§è¡Œå°±æ°¸è¿œä¸ä¼šæˆåŠŸã€‚

### ä»£å¸è½¬è´¦
æœ‰çš„ä»£å¸æ ‡å‡†å…è®¸ä¸€ç§è½¬è´¦å¤„ç†ç¨‹åºï¼Œä¼šä»¥æ¥æ”¶æ–¹åä¹‰æ¥å‘èµ·ä¸€ä¸ªæ ‡å‡†çš„å‡½æ•°è°ƒç”¨ï¼ˆä¾‹å¦‚ `onERC721Received()`ï¼‰æ¥ä½œä¸ºå¯¹æ¥æ”¶åˆ°ä»£å¸è½¬è´¦çš„ååº”ï¼ˆç±»ä¼¼äºETHè½¬è´¦å¯ä»¥è§¦å‘æŸäº›ä»£ç æ‰§è¡Œï¼‰ã€‚æ‰€ä»¥æŸäº›ä»£å¸è½¬è´¦ç»™æ™ºèƒ½åˆçº¦ä¹Ÿä¼šå…·æœ‰åƒETHè½¬è´¦é‚£æ ·çš„é£é™©ã€‚

### Stuck Assets
Assets (ETH, ERC20s, ERC721s, etc.) held by an EOA are almost always accessible and transferrable by whomever knows the private key. On the other hand, smart contracts are not controlled by a private key. If a contract does not expose functions to directly interact with an asset it holds, they may become permanently stuck in that contract. This is one of the motivations for token standards like `ERC721` and `ERC1155` having "safe" transfer functions that require a contract recipient to respond to an on-transfer hook to signal deliberate support for receiving tokens.

It should be clear by now that interactions with smart contracts are generally considered more risky because their behavior is less predictable and can kick off complex interactions that your protocol may not be designed to handle. But it can sometimes be equally disastrous to interact with an EOA when you expect a contract. For these reasons, some contracts will opt to impose restrictions on the types of accounts they interact with. But how do you identify them?

## `ADDRESS.code.length` Check
It's actually quite simple to check if an address has code in it, and is therefore a contract. Solidity exposes this with the `ADDRESS.code.length` syntax, which returns the (byte) size of the code at that `ADDRESS`. If this value is nonzero, there is a smart contract there.

```solidity
 function _isContractAt(address a) view returns (bool) {
    return a.code.length != 0;
 }
 ```

It's important to understand that this check does not guarantee that the address is an EOA. It only checks if there is code at the address *presently*. It may not be an EOA but a yet-to-be deployed contract address (which are in fact [deterministic](../factory-proofs/)). A contract could even be deployed to that address in the same transaction, right after you've performed this check and lost execution control. It's also possible for a contract to `selfdestruct()` its code away and have it reinstated with `CREATE2`. Therefore, this specific approach is considered a weak EOA check and is usually reserved for non-critical sanity checks or where it only matters that an address is not a contract during a brief call window.

 ## `tx.origin` Check
 This is a reliable and cheap way to guarantee that an address is a *certain* EOA. In solidity, `tx.origin` returns the address that signed the current transaction, which must always be an EOA. Thus, if an address in question is equal to `tx.origin`, you can be sure it's an EOA and will always be one. You will frequently see this check as a modifier on user-facing functions that seek to minimize their attack surface by ensuring that they can only be called by an EOA.
 
 ```solidity
 modifier onlyEOA() {
    require(tx.origin == msg.sender, 'only EOA can call');
    _;
 }
 ```
 
 Keep in mind that this check can only draw a definitive conclusion if the address matches `tx.origin`. Addresses that do not match `tx.origin` can still be EOAs.

 ## Transaction Proofs

 Assuming your contract has access to historical a block hash where an EOA has made a transaction, there's another definitive, albeit obscure and extremely technical, way to check that it is an EOA which doesn't require it to be the current `tx.origin`.

 Every mined Ethereum block is uniquely identified by a "block hash," which is essentially analogous to the hash of the [properties](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) that make up an Ethereum block. The one block property we're most interested here is the `transactionsRoot`. This is a [merkle root](../merkle-proofs/) of all the transactions (actually their hashes) that have been included in that block. Because only EOAs can sign/originate transactions, you can theoretically prove that an arbitrary address is an EOA if you supply proof to your contract that a transaction sent by the address in question is part of a verifiable block hash.
 
 The details of this approach are a bit of a rabbit hole so we won't go much deeper. But in case you do decide to explore it yourself, let me warn you that this approach is only immediately feasible with transactions that were mined in the last [256 blocks](https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#block-and-transaction-properties) on mainnet. Anything older than that, while not impossible, will require extra legwork. 

## Do You Really Need EOA Checks?
These checks are often employed as a security shortcut to mitigate reentrancy, composability attacks (e.g., arbitrage or oracle manipulation), or to just add a speed bump to certain operations (e.g., preventing a contract from minting multiple NFTs in a transaction). Depending on the type of check you use and where you use it, this protection may only be partial. It's important to be aware that EOAs can still perform multiple, direct calls in a single block (but across different transactions), which has been made even easier with the introduction of [flashbot bundles](https://docs.flashbots.net/flashbots-auction/searchers/advanced/understanding-bundles). Still, many developers will continue to opt for this strategy and it's hard to fault them because these checks are fairly cheap, can often reduce the attack surface, and sometimes partial protection is better than none at all, especially in relatively low-stakes applications.

There is a major downside to using EOA checks, and that is in limiting your protocol's composability with other contracts which may try to build on top of yours. Some audiences also have a meaningful share of users that transact from smart wallets, which could be excluded from participating. But not all protocols need to worry about composability, and they may be OK with excluding smart wallet users. It really depends on who you think will be consuming your protocol.

Another point to make is that most attack vectors that EOA checks are used to mitigate can often be better addressed through specific fixes (like reentrancy guards, timelocks, pull patterns, etc), which will not impose restrictions on what kinds of addresses your contract can interact with.

## The Demo
The [demo](./KingOfTheHill.sol) showcases 3 contracts that implement an on-chain king-of-the-hill game. Becoming king costs ETH and lets you set a custom message on the contract. Anyone can become the new king by paying more than the last king did through `takeCrown()`. The amount paid by the new king goes to the old king, and so on.

The naive version, `BrickableKingOfTheHill`, is vulnerable to a denial-of-service attack if the previous king is a contract that reverts when it receives ETH. This causes the call to `takeCrown()` to fail when the payment is sent to the old king (see the [tests](../../test/KingOfTheHill.t.sol#L48) for an example). The result is that the evil contract king remains king forever. The `OnlyEOAKingOfTheHill` version fixes this by simply adding an `onlyEOA` modifier to `takeCrown()`. This ensures that the every king is, and always will be, an EOA, which cannot revert on ETH transfers. The `ClaimableKingOfTheHill` version also fixes this by only sending ETH to the last king if they have no code at their address, otherwise it will set aside the ETH for the last king to `claim()` it in a separate call.
